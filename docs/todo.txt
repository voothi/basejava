?- isElementOfArray и getIndex делают одно и то же, просто возвращают разные значения. isElementOfArray  можно удалить
: Заменить не удалось
+ setSize(SIZE_AFTER_CLEAR);
просто size = 0
***
+ STORAGE_SIZE_CREATE слово CREATE лишнее - это же переменная, а не метод. Глаголов в именах переменных быть не должно
+ counterElementsOfStorage
  можно просто counter или size
+ поле типа int при создании объекта и так автоматически инициализируется 0. явно это делать не нужно
+ в методе int size() { уже ни какая логика не нужно. Просто return counterElementsOfStorage
+ после очистки null выводиться не должны.
    А иначе это означает, что ты
      не обнулил счетчик резюме после очистки
    counterElementsOfStorage = 0;
+ в delete создавать новый массив не нужно. Делай все на текущем
Исходный, заполненный
mass  |1|2|3|4|
index  0 1 2 3

Удалил элемент index = 0
mass  | |2|3|4|
index  0 1 2 3

* Сохранить размерность массива
* Новый не создавать

Сдвиг элементов index + 1 на 1 позицию влево
        <2 3 4
mass  | |2|3|4|
index  0 1 2 3









- STORAGE_SIZE = 10000
***
. Исправить resume.uuid = uuid; прямое обращение. Нарушение принципа ООП - Инкапсуляция.
. Названия классов - ?
. return 0; ArrayStorage.java есть нуль, а в switch MainArray.java - нет. Почему?
. Почему printAll не в ArrayStorage?
Предложение: вынести в отдельную структуру
. printAll() MainArray.java переменная all - ? Нет контекста у названия. В MainTestArrayStorage.java
её нет.
  . Дублирование кода printAll() в MainArray.java, MainTestArrayStorage.java
. Название. Лучше поменять на create, судя по текущей реализации в коде. Иначе,
Почему в save() создаем новый экземпляр объекта?
                case "save":
                    resume = new Resume();
. get ArrayStorage.java @Overwrite toString(), кастомно, для вывода массива резюме.